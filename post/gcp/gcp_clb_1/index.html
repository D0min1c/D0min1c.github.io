<!doctype html><html class=no-js lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#1b1b1b"><title>GCP-Cloud Load Balancer(1) 내용정리 | 255.255.248.0</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content><meta property="og:title" content="GCP-Cloud Load Balancer(1) 내용정리"><meta property="og:description" content="GCP CLB를 사용해본 뒤,  서비스의 특징에 대해 사용 후 정리해봤습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://21sub.net/post/gcp/gcp_clb_1/"><meta property="og:image" content="https://21sub.net/post/gcp/gcp_clb_1/featured.png"><meta itemprop=name content="GCP-Cloud Load Balancer(1) 내용정리"><meta itemprop=description content="GCP CLB를 사용해본 뒤,  서비스의 특징에 대해 사용 후 정리해봤습니다."><meta itemprop=wordCount content="1249"><meta itemprop=image content="https://21sub.net/post/gcp/gcp_clb_1/featured.png"><meta itemprop=keywords content="gcp,public cloud,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://21sub.net/post/gcp/gcp_clb_1/featured.png"><meta name=twitter:title content="GCP-Cloud Load Balancer(1) 내용정리"><meta name=twitter:description content="GCP CLB를 사용해본 뒤,  서비스의 특징에 대해 사용 후 정리해봤습니다."><link rel=stylesheet href=/css/bundle.css><link rel=stylesheet href=/css/custom.css><link rel=icon href=/icons/16.png sizes=16x16 type=image/png><link rel=icon href=/icons/32.png sizes=32x32 type=image/png><link rel=manifest href=/manifest.json><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-199142344-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="body kind-page"><header class=header><a class=logo href=/>255.255.248.0</a><nav class="main-nav main-nav--right" role=navigation><button id=toggle class=main-nav__btn aria-label="Menu toggle" aria-expanded=false tabindex=0><div class=main-nav__btn-box tabindex=-1><svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18"><path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/><path class="icon-menu__x" d="M11.55 9 18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55.0 9 6.45 15.45.0 18 2.55 11.55 9z"/></svg></div></button><ul id=menu class=main-nav__list><li class=main-nav__item><a class=main-nav__link href=/%EA%B0%9C%EC%9D%B8/><span class=main-nav__text>About Dominic</span></a></li></ul></nav></header><div class=primary><main class=main><nav class="breadcrumb block" aria-label=breadcrumb><ol class=breadcrumb__list><li class=breadcrumb__item><a class=breadcrumbs__link href=/>21sub.net</a></li><li class=breadcrumb__item><a class=breadcrumbs__link href=/post/>Posts</a></li><li class="breadcrumbs__item breadcrumb__item--active" aria-current=page>GCP-Cloud Load Balancer(1) 내용정리</li></ol></nav><div class="single block"><article class=entry><figure class="entry__featured featured"><img class=featured__img src=/post/gcp/gcp_clb_1/featured.png alt=featured.png></figure><div class="entry__meta meta mb"><span class="entry__meta-categories meta-categories"><span class=meta-categories__list>Categories:
<a class=meta-categories__link href=/categories/cloud/ rel=category>cloud</a></span></span></div><h1 class=entry__title>GCP-Cloud Load Balancer(1) 내용정리</h1><div class=entry__content><p>GCP CLB를 사용해본 뒤, 서비스의 특징에 대해 사용 후 정리해봤습니다.</p><h2 id=배경>배경</h2><p>Load Balancing (이하 LB)는 Client로부터 들어오는 트래픽을 여러 Backend Server (Instance, VM)에 분산하는 기능을 가지고 있습니다. 이를 통해 트래픽에 의해 Backend Server의 리소스가 과다하게 점유되어 터지는 것을 방지하고자 트래픽 즉 부하들을 분산시켜 서비스의 고가용성을 얻음과 동시에 성능적인 이점을 가져갈 수 있습니다.</p><p>AWS에서 Elastic Load Balancing로 서비스되는 것처럼 GCP의 로드밸런서는 CLB(CloudLoadBalancer)로 서비스합니다.</p><p>두 벤더 모두를 경험해본 결과, AWS는 사용자에게 보다 친절합니다. 하지만 세세한 설정까지 원하는 사용자에게는 다소 불편합니다.</p><p>GCP는 일반적인 사용자에게 불친절할 정도로 세세한 설정이 필요합니다. 하지만 티끌까지 optimzing을 원하는 사용자에게는 이보다 좋은 플랫폼은 없다고 느껴집니다.</p><p>사용 간 느꼈던 점을 기록하기 앞서 GCP에서 서비스하는 LB의 특징들을 요약해봤습니다.</p><p>(Google Docs가서 보시면 보다 정확한 내용을 알 수 있습니다.)</p><h2 id=clb의-종류>CLB의 종류</h2><hr><ul><li><strong>HTTP/HTTPS Load Balancing</strong></li><li><strong>TCP/UDP Load Balancing</strong></li><li><strong>TCP/SSL Proxy Load balancing</strong></li></ul><hr><p>CLB는 어느 프로토콜을 지원하는지에 따라 3가지의 종류로 나뉘어집니다. GCP에서의 표기와 다를 수 있습니다.</p><p>기능적으로 헷갈리기는 부분이 있어, 제가 보기쉽게 나눠 표기하였습니다.</p><p>중요한건 HTTP(S), TCP, TCP proxy LB의 차이를 명확하게 구분지을 줄 알아야 서비스에서 원하는 로드밸런서를 선택할 수 있다는 점입니다.</p><p>LB를 통한 로드밸런싱을 한다고 모든 서비스가 무적이면 좋겠지만 아닙니다.</p><p>백엔드 서비스가 빵빵해도 LB 즉 프론트 단의 QPS의 한계로 인해 client의 request를 드랍할 수 도 있는것이기 떄문입니다.</p><p>그럼 SSL Handshaking은 무조건 백엔드 서비스에서 처리하는 것이 답일까요? 그것도 아닙니다.</p><p>L4에서 SSL offloading을 통한 백엔드 서비스의 부하를 줄일 수 있는거고 반대로 L4의 부하를 줄이기 위해 백엔드에서 SSL handshaking을 할 수 있는것이죠. ~_~ 무조건 이거다 ! 는 없습니다. 상황에 맞게..!</p><hr><h2 id=clb의-특징>CLB의 특징</h2><ul><li>프런트엔드 역할을 하는 단일 <strong>anycast IP address</strong></li><li>AWS의 ELB를 사용하던 유저들은 다소 생소할 수 있습니다. 왜냐면 AWS ELB는 FQDN을 통해 ELB를 제공하기 때문입니다.</li></ul><p>이는 AWS ELB의 Node라는 개념에 의해 어쩔 수 없이 Endpoint로 FQDN을 제공할 수 밖에 없는 AWS의 특징입니다.
그러나 GCP CLB는 트래픽을 IP를 통해 받을 수 있도록 프런트엔드에 external IP를 부여할 수 있습니다.</p><ul><li><p>**백엔드의 자동 지능형 자동 확장 **</p><ul><li>LB는 SDN 형태로 Software 적으로 만들어진 것이며, 기존의 물리적인 장비가 갖고 있던 하드웨어적 처리 성능 한계를 갖지는 않습니다.</li><li>SDN의 특성 상, 개념적인 하나의 LB가 하나의 Software Process를 의미하지 않으며, 필요에 따라 (백엔드 구성에 맞물려) 실제의 Data Plane을 담당하는 구성요소는 수평 확장되는 구조입니다.</li><li>위의 특성들에 의해 전반적으로 성능의 한계는 Backend Services의 규모/구성에 의해 결정되는 요소가 오히려 더 크다고 볼 수 있습니다.</li><li>병목현상이 일어난다면 AWS는 node에 대한 이슈까지도 염두해두지만 GCP에서는 QPS에 대한 측정 자료나 Backend latency, Total latency 등의 값을 참고하는 것이 이슈를 해소하기 좋습니다.</li></ul></li><li><p>단일 리전에서 애플리케이션을 사용할 때의 리전 부하 분산</p></li><li><p>전 세계에서 애플리케이션을 사용할 때의 전역 부하 분산 <strong>(Premium 등급의 Network Tier가 필요)</strong></p></li><li><p>CLB 백단에 있는 모든 백엔드가 auto scaling되진 않습니다.
인스턴스 그룹이 관리형(Managed)인지 비관리형(unManaged)인지에 따라 다르게 동작하며 이 부분은 인스터스 그룹에 대한 이해가 필요합니다.</p></li><li><p>캐시된 콘텐츠 전달을 위한 <a href="https://cloud.google.com/cdn?hl=ko">Cloud CDN</a>과의 통합</p></li></ul><p><img src=/img/session_affi.jpg alt="This is an image"></p><ul><li>기본적으로 5-tuple hash 기반의 부하분산을 지원하지만, Statefull한 애플리케이션을 구성했을 경우를 대비하여 세션 어피니티를 지원합니다. 세션 어피니티는 백엔드가 정상이고 용량이 있는 한 동일한 클라이언트의 모든 요청을 동일한 백엔드로 전송합니다.</li></ul><hr><h2 id=cloud-load-balancer-기초>Cloud Load Balancer 기초</h2><p>크게 <strong>백엔드 서비스</strong>, <strong>호스트 및 경로규칙(HTTP/s)</strong>, <strong>프런트 엔드</strong>로 나뉘며 각기 항목별 세부적인 항목들이 있습니다.</p><h4 id=backend>Backend</h4><p><img src=/img/backend_1.JPG alt="This is an image"></p><ul><li>백엔드 유형 / backend port / 인스턴스 그룹 / 밸런싱 모드 / A capacity scaler / 타임아웃 / 세션어피니티 / 헬스체크 (포트 or 경로)</li></ul><h4 id=호스트-및-경로-규칙-https>호스트 및 경로 규칙 (HTTP/s)</h4><p><img src=/img/lb_host.jpg alt="This is an image"></p><ul><li>호스트 / 경로 / 백엔드</li></ul><h4 id=frontend>FrontEnd</h4><p><img src=/img/lb_front.jpg alt="This is an image"></p><ul><li>프로토콜 / 네트워크 계층 / external IP / Front Port</li></ul><h3 id=httphttps-load-balancing>HTTP/HTTPS Load Balancing</h3><p><img src=/img/HTTP_LB.jpg alt="This is an image"></p><ul><li>7계층에서 동작합니다.</li><li>여러가지 백엔드 유형을 지원하며, <strong>대상 HTTP(S) 프록시</strong>는 클라이언트로부터 요청을 받습니다.</li><li>HTTP(S) 프록시는 트래픽 라우팅을 결정하기 위해 URL 맵을 사용하여 요청을 판단(컨텐츠 기반 부하분산)합니다.</li><li>프록시는 SSL 인증서를 사용하여 통신을 인증할 수도 있습니다.</li><li>세션 유지 시간은 600초로 고정되어있습니다.</li></ul><p>(websocket에는 적용되지않지만, 일반적으로 백엔드가 조기에 세션을 끊는 일이 발생하지 않도록 600초보다 길게 KeepAliveTime Out값을 설정하는 것이 좋습니다.)</p><ul><li>websocket을 지원합니다.</li><li>gPRC를 지원합니다. (AWS ALB에도 2020년 11월 추가됐습니다.)</li><li>QUIC를 지원합니다 . (Quick UDP Internet Connections / HTTP3 )</li></ul><h3 id=tcpudp-load-balancing>TCP/UDP Load Balancing</h3><p><img src=/img/tcp_lb.jpg alt="This is an image"></p><ul><li>4 계층에서 동작합니다.</li><li>pass-through LB 입니다. (글로벌 서비스를 위해 백엔드에서 모든 Ingress IP/port에 대한 허용이 필요합니다. )</li><li>수신(ingress)/요청(request) 패킷만 lb를 통과 - 송신(engress)/응답(response) 패킷은 lb를 거치지 않고 바로 client로 가는 DSR로 동작합니다.</li><li>Proxy가 아닙니다.<ul><li>부하 분산된 패킷은 소스 IP가 변경되지 않은 백엔드 VM에서 수신됩니다.</li><li>부하 분산된 연결은 백엔드 VM에 의해 종료됩니다.</li><li>백엔드 VM의 응답은 부하 분산기를 통하지 않고 클라이언트에 직접 전달됩니다. (위에서 설명한 DSR이 이것입니다.)</li></ul></li><li>연결 추적 테이블과 구성 가능한 일관된 해싱 알고리즘을 사용하여 트래픽이 백엔드 VM에 분산되는 방식을 결정합니다.</li><li>백엔드 VM이 비정상 상태여도 TCP 패킷에 응답하면 세션을 다른 백엔드 VM으로 넘기지 않습니다.</li></ul><h3 id=tcpssl-proxy-load-balancing>TCP/SSL proxy Load Balancing</h3><p><img src=/img/tcp_pr_lb.jpg alt="This is an image"></p><ul><li>TCP 연결을 통해 들어오는 트래픽이 부하 분산 레이어에서 종료된 후 TCP 또는 SSL을 통해 사용 가능한 가장 가까운 백엔드로 전달됩니다.</li><li>자동으로 트래픽을 사용자와 가장 가까운 백엔드로 라우팅합니다.</li><li>TCP 80 or 8080 Port를 지원하지 않습니다. (HTTP/s LB로 쓰면됩니다.)</li><li>TCP 프록시 부하 분산기는 역방향 프록시 부하 분산기입니다. 부하 분산기는 수신 연결을 종료한 후 부하 분산기에서 백엔드로 새 연결을 엽니다. 역방향 프록시 기능은 Google 프런트엔드(GFE)에서 제공합니다.</li></ul><h2 id=사용하면서-배운-것들>사용하면서 배운 것들</h2><h3 id=1-lb를-사용할-때-백엔드-서비스-구성은-생각보다-난해한-포인트들이-있다>1. LB를 사용할 때 백엔드 서비스 구성은 생각보다 난해한 포인트들이 있다.</h3><p>우선 LB의 백엔드 구성 간 선택지는 기본적으로 백엔드 서비스, 버킷, TCP에는 인스턴스 Pool을 직접 연결하기도 하지만
저의 경우 GCP 내의 VM으로 트래픽을 전달받아야하기 때문에 백엔드 서비스의 인스턴스 그룹 혹은 인스턴스 Pool로 셋팅합니다.</p><p>이때 그룹의 종류가 두가지로 나뉘는데 앞서 1편에서 말했던 인스턴스 그룹의 두 종류인 비관리형(Unmanaged Instance Group)과 관리형(Managed Instance Group) 그룹입니다.</p><p>1-1 <strong>MIG</strong>는 단일 region 내 멀티 zone에 VM 인스턴스를 분산함으로써 single zone failure 에 대응하여 워크로드의 고가용성을 높일 수 있습니다.</p><p>예를 들어, zonal failure 가 발생하거나 특정 zone 내에 위치한 인스턴스들에 장애 발생시, regional MIG 에 포함된 다른 zone에서 실행되는 인스턴스가 트래픽을 처리함으로써 고가용성을 구성할 수 있습니다.</p><hr><p><strong>[MIG 의 특징]</strong></p><ul><li><p>애플리케이션 로드를 멀티 zone 으로 분산</p></li><li><p>최대 2,000개의 인스턴스까지 관리 가능 (zonal MIG의 2배)</p></li><li><p>멀티 zone 을 사용함으로써 zonal failure 및 단일 zone 내 인스턴스 그룹의 오작동과 같은 시나리오로부터 보호</p></li><li><p>zonal failure 발생 혹은 zone 내 인스턴스 장애시, regional MIG에 포함된 다른 zone 에서 트래픽을 처리</p></li></ul><hr><p>1-2 <strong>UIG</strong>는 단순히 같은 zone내의 인스턴스들을 집합화 시킨 server pool이라고 이해하면 됩니다.</p><p>인스턴스 템플릿이 필요하지 않습니다. 단지 같은 zone내의 인스턴스라면 그룹화시켜 LB를 통해 트래픽을 받을 수 있습니다.</p><p>UIG를 사용할지 MIG를 사용할지는 어떤 서비스를 제공하는지에 따라 다릅니다.
[제가 근무하는 인프라실에서는 UIG로 구성합니다.]</p><p>MIG는 동일한 구성의 인스턴스를 여러 개 만들기 위한 것입니다. 기존 인스턴스 템플릿을 업데이트하거나 생성된 인스턴스 템플릿을 변경할 수 없습니다. 구성을 변경해야 하는 경우 새 인스턴스 템플릿을 만듭니다.</p><p>그러나 UIG는 전혀다른 스펙과 구성의 인스턴스들을 그룹핑 시킬 수 있습니다.</p><p>따라서 게임서비스의 특성 상 순간적인 트래픽이 발생하기보단 꾸준한 유저들의 동접 수를 대응하기에 예상 트래픽의 최대치를 기준으로 서버를 생성하고 일정기간 모니터링하여 optimizing하는 방법으로 GCP를 활용하고 있습니다.</p><p>그러나 항상 single zone failure에 대한 고민을 하고 있습니다. (좋은 방법 있을까요? (°∀°)b)</p><hr><h3 id=2-global-healthcheck>2. Global HealthCheck</h3><p>AWS를 사용할때는 ALB의 sg를 참조하여 백엔드 EC2의 보안그룹을 유연하게 구성했다면, 다행히 GCP LB에서는 LB에 node 개념이 없습니다.</p><p>다만, Global HC라고하는 백엔드에 연결하는 전역 및 리전별 상태 확인 시스템을 제공합니다.</p><p><img src=/img/HC.jpg alt="This is an image"></p><ul><li>Global Healthcheck가 존재합니다. (백엔드 서비스의 방화벽에서 필수적으로 Ingress를 허용해줘야 합니다. )</li></ul><p>각 연결 시도를 <em>프로브</em>라고 부르고, 각 상태 확인 시스템을 <em>프로버</em>라고 부릅니다.</p><h3 id=3-인스턴스와-인스턴스-그룹-재사용>3. 인스턴스와 인스턴스 그룹 재사용</h3><p>하나의 인스턴스는 동시에 여러 인스턴스 그룹에 그룹핑될수 없습니다. 만약 한대의 인스턴스 내에 여러 서비스가 올라가있는 상태라면 Instance Group으로 나눌수는 없으니, 백엔드 포트를 서비스 마다 열어두고, 한대의 인스턴스 그룹을 여러 LB로 연결하는 방식으로 재사용 해야합니다.</p><p>위 기능들은 다음 포스팅에서 검증해서 보여드릴 예정입니다.</p><p>감사합니다.</p><h3 id=4-결론>4. 결론</h3><p>결론적으로 CLB는 유저의 Ingress/Request에 대한 트래픽을 어떤 방식으로 백엔드에 전달하는가에 따라 종류가 나뉘며</p><p>크게는 OSI 7 Layer에 의해 (HTTP, TCP/UDP)로 나뉘며, Traffic Flow 자체는 Front 단에서의 전송방식 및 Egress/Response를 기준으로 구별합니다. (Proxy의 유무)</p><p>HTTP/s or TCP (Proxy) LB의 경우</p><ul><li>IPv4, IPv6 프로토콜을 모두 지원하며, 전달 규칙(Forwarding rule)을 HTTPS proxy에서 URL map을 통해 각 백엔드 서비스로 프록시 처리됩니다.</li><li>네트워크 등급에 따라 Global, Regional LB의 지원 여부가 달라집니다.</li><li>기본적으로 균등하게 부하를 분산하지만, 아주 작은 수의 요청은 균등하게 분배되지 않을 수 있습니다</li><li>Session affinity를 통해 해시를 기반으로 특정 클라이언트의 요청을 동일 백앤드 VM으로 전달하도록 설정 할 수 있습니다.</li><li>SSL offloading을 지원합니다.</li></ul><p><img src=/img/gcp_lb.jpg alt="This is an image"></p><p>친절한 GCP에서 제공하는 LB 선택방법입니다.</p><p>간략하게 특징들에 대해 정리해봤습니다.</p><p>감사합니다.</p></div><footer class=entry__footer><div class=entry__tags><a class="entry__tag btn" href=/tags/gcp/>gcp</a>
<a class="entry__tag btn" href=/tags/public-cloud/>public cloud</a></div></footer></article></div></main><div class="authorbox block"><div class=author><figure class=author__avatar><img class=author__img alt="Dominic avatar" src=/img/avatar.png height=90 width=90></figure><div class=author__body><div class=author__name>Dominic</div><div class=author__bio>Dominic's true identity is unknown. Maybe he is a cute fairy or slave :D</div></div></div></div><div class="related block"><h3 class=related__title>Related</h3><ul class=related__list><li class=related__item><a class=related__link href=/post/gcp/gcp_clb_2/>GCP-Cloud Load Balancer(2) 테스트</a></li><li class=related__item><a class=related__link href=/post/gcp/gcp_issue/>아니 글쎄 갑자기 인스턴스가 죽었다니까요? - GCP</a></li><li class=related__item><a class=related__link href=/post/aws/aws_issue/>아니 글쎄 갑자기 인스턴스가 죽었다니까요? - AWS</a></li></ul></div><section class="comments block"><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"dominic"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><footer class=footer><div class="footer__social social"><a class=social__link target=_blank rel="noopener noreferrer" href=https://www.instagram.com/seob.199b><svg class="social__icon" aria-label="Instagram" role="img" width="32" height="32" viewBox="0 0 512 512"><g fill="none" stroke-width="29"><rect height="296" rx="78" width="296" x="108" y="108"/><circle cx="256" cy="256" r="69"/></g><circle cx="343" cy="169" r="19"/></svg></a><a class=social__link target=_blank rel="noopener noreferrer" href=https://linkedin.com/in/hanseob-lee-9655781aa><svg class="social__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg></a><a class=social__link target=_blank rel="noopener noreferrer" href=https://github.com/D0min1c><svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg></a></div><div class=footer__copyright>© 2021 Binario. <span class=footer__copyright-credits>Powered by <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/vimux/binario rel="nofollow noopener" target=_blank>Binario</a> theme.</span></div></footer><script src=/js/menu.js></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script><script src=/js/custom.js></script></body></html>